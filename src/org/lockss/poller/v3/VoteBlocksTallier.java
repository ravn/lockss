/*
 * $Id: VoteBlocksTallier.java,v 1.4 2013-05-29 17:18:12 barry409 Exp $
 */

/*

Copyright (c) 2013 Board of Trustees of Leland Stanford Jr. University,
all rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
STANFORD UNIVERSITY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Stanford University shall not
be used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from Stanford University.

*/

package org.lockss.poller.v3;

import java.io.*;
import java.nio.*;
import java.util.*;

import org.lockss.config.Configuration;
import org.lockss.config.CurrentConfig;
import org.lockss.daemon.ShouldNotHappenException;
import org.lockss.hasher.HashBlock;
import org.lockss.hasher.HashResult;
import org.lockss.protocol.VoteBlock;
import org.lockss.protocol.VoteBlocks;
import org.lockss.protocol.VoteBlocksIterator;
import org.lockss.util.*;

/**
 * Representation of the tally of two votes in a symmetric poll,
 * that is the one generated by the voter while it is creating its
 * vote, and the one generated at the poller while it is tallying
 * that vote. This class encapsulates the process of comparing
 * two VoteBlocks instances by comparing their lists of VoteBlock
 * instances and the hashes of the versions they contain.
 */
public class VoteBlocksTallier {
  private static final Logger log = Logger.getLogger("VoteBlocksTallier");
  // XXX DSHR cannot keep these lists of URLs in memory - need to put them
  // XXX DSHR on disk, and make collecting them optional since we actually
  // XXX DSHR only need the counts
  private boolean keepUrlLists = false;
  private ArrayList<String> agreeUrl = new ArrayList<String>();
  private int agreeCount = 0;
  private ArrayList<String> disagreeUrl = new ArrayList<String>();
  private int disagreeCount = 0;
  private ArrayList<String> voterOnlyUrl = new ArrayList<String>();
  private int voterOnlyCount = 0;
  private ArrayList<String> pollerOnlyUrl = new ArrayList<String>();
  private int pollerOnlyCount = 0;

  private static final String PREFIX = Configuration.PREFIX + "poll.v3.";

  /**
   * If true, lists of agree/disagree/voterOnly/pollerOnly URLs will
   * be kept. XXX see comment above
   */
  public static final String PARAM_KEEP_URL_LISTS =
    PREFIX + "keepurlLists";
  public static final boolean
    DEFAULT_KEEP_URL_LISTS = false;

  public VoteBlocksTallier() {
  }

  public VoteBlocksTallier(VoteBlocks voterBlocks, VoteBlocks pollerBlocks) {
    keepUrlLists = CurrentConfig.getBooleanParam(PARAM_KEEP_URL_LISTS,
						 DEFAULT_KEEP_URL_LISTS);

    tallyVoteBlocks(voterBlocks, pollerBlocks);
  }

  /**
   * Used by the voter in a symmetric poll to tally the VoteBlocks
   * in the receipt message aginst the VoteBlocks object, which
   * was created during voter generation.
   * @param poller A ParticipantUserData instance to represent the poller
   * @param voterBlocks The VoteBlocks the voter generated
   * @param pollerBlocks The VoteBlocks the poller sent in the receipt.
   */
  public void tallyVoteBlocks(VoteBlocks voterBlocks,
			      VoteBlocks pollerBlocks) {
    // VoteBlocks.iterator() delivers VoteBlock instances in URL order.
    if (voterBlocks == null) {
      throw new IllegalArgumentException("voterBlocks null");
    }
    if (pollerBlocks == null) {
      throw new IllegalArgumentException("pollerBlocks null");
    }
    try {
      VoteBlocksIterator vIterator = voterBlocks.iterator();
      VoteBlocksIterator pIterator = pollerBlocks.iterator();
      VoteBlock vBlock = null;
      VoteBlock oldVoterBlock = null;
      VoteBlock pBlock = null;
      VoteBlock oldPollerBlock = null;
    
      while (true) {
	if (vBlock == null && vIterator.hasNext()) {
	  vBlock = vIterator.next();
	}
	if (vBlock != null && oldVoterBlock != null) {
	  if (vBlock.compareTo(oldVoterBlock) < 0) {
	    throw 
	      new ShouldNotHappenException("VoteBlocks should be in order.");
	  }
	  oldVoterBlock = vBlock;
	}
	if (pBlock == null && pIterator.hasNext()) {
	  pBlock = pIterator.next();
	}
	if (pBlock != null && oldPollerBlock != null) {
	  if (pBlock.compareTo(oldPollerBlock) < 0) {
	    // The poller has sent blocks out of order.  Poison the
	    // agreeCount so that we don't become a willing repairer.

	    // NOTE: In the poller code, an out of order vote is
	    // treated as the end of any VoteBlock for that voter. But
	    // in the poller there is reason to continue tallying when
	    // one voter is out of order. The parallel here would be
	    // to not ask for any more blocks from the poller but
	    // continue to count the voter-only blocks. Instead, just
	    // make sure that the agreement is low for a poller with
	    // out of order blocks.
	    log.warning("Poller VoteBlocks out of order");
	    this.agreeCount = 0;
	    break;
	  }
	  oldPollerBlock = pBlock;
	}
	if (vBlock == null && pBlock == null) {
	  // Run out of blocks in both iterators
	  break;
	} else if (vBlock == null) {
	  // Poller has blocks after Voter
	  if (keepUrlLists) {
	    pollerOnlyUrl.add(pBlock.getUrl());
	  }
	  pollerOnlyCount++;
	  // Consume the Poller's VoteBlock
	  pBlock = null;
	} else if (pBlock == null) {
	  // Voter has blocks after Poller
	  if (keepUrlLists) {
	    voterOnlyUrl.add(vBlock.getUrl());
	  }
	  voterOnlyCount++;
	  // Consume the Voter's VoteBlock
	  vBlock = null;
	} else {
	  String vUrl = vBlock.getUrl();
	  String pUrl = pBlock.getUrl();
	  int comparison = vBlock.compareTo(pBlock);
	  if (comparison == 0) {
	    log.debug3("Both have " + vUrl);
	    // Voter and Poller both have this URL
	    if (voteBlockAgree(vBlock, pBlock)) {
	      if (keepUrlLists) {
		agreeUrl.add(vUrl);
	      }
	      agreeCount++;
	    } else {
	      if (keepUrlLists) {
		disagreeUrl.add(vUrl);
	      }
	      disagreeCount++;
	    }
	    // Consume both VoteBlocks
	    vBlock = pBlock = null;
	  } else if (comparison < 0) {
	    log.debug3("Voter has " + vUrl);
	    // Voter has this URL, Poller doesn't
	    if (keepUrlLists) {
	      voterOnlyUrl.add(vUrl);
	    }
	    voterOnlyCount++;
	    // Consume the Voter's VoteBlock
	    vBlock = null;
	  } else {
	    log.debug3("Poller has " + vUrl);
	    // Poller has this URL, Voter doesn't
	    if (keepUrlLists) {
	      pollerOnlyUrl.add(pUrl);
	    }
	    pollerOnlyCount++;
	    // Consume the Poller's VoteBlock
	    pBlock = null;
	  }
	}
      }
    } catch (IOException ex) {
      log.error("IOException while tallying symmetric poll", ex);
      return;
    }
  }

  // todo(bhayes): Can HashBlock and VoteBlock share an interface?
  // VoteBlocksTallier#makePlainMap is somewhat like
  // HashBlockCompareImpl#makePlainMap, but works with a VoteBlock
  // rather than a HashBlock, and so ends up annoyingly
  // different. Likewise voteBlocksAgree is very similar to
  // HashBlockCompareImpl#compare.

  // Make a Map from the plain hash of each version to that version.
  // Note: Called with our own VoteBlocks, so throwing on unexpected
  // errors -- like illegal hash values -- rather than recovering.
  private Map<HashResult, VoteBlock.Version>
    makePlainMap(VoteBlock voteBlock) {
    Map<HashResult, VoteBlock.Version> plainMap =
      new <HashResult, VoteBlock.Version>HashMap();
    VoteBlock.Version[] vbVersions = voteBlock.getVersions();
    for (int versionIndex = 0; versionIndex < vbVersions.length;
	 versionIndex++) {
      VoteBlock.Version vbVersion = vbVersions[versionIndex];
      if (vbVersion.getHashError()) {
	// Only log the hash error in the VoteBlock at
	// initialize. There's probably a more detailed error in the
	// log.
	log.warning("VoteBlock version "+versionIndex+" had hashing error.");
      } else {
	HashResult plainHash = HashResult.make(vbVersion.getPlainHash());
	
	// We could check for a plainHash already in the map, and
	// check that all the nonced hashes match. If they do not,
	// something odd is happening in the hasher. But it's not
	// worth it.
	plainMap.put(plainHash, vbVersion);
      }
    }
    return plainMap;
  }

  /**
   * Compare two VoteBlock instances, one from voter and one from poller.
   * @param vBlock VoteBlock from voter
   * @param pBlock VoteBlock from poller
   * @return true if at least one voter version agrees with a poller version
   */
  protected boolean voteBlockAgree(VoteBlock vBlock, VoteBlock pBlock) {
    // Build the map from our versions.
    Map<HashResult, VoteBlock.Version> plainMap = makePlainMap(vBlock);

    // Check each of the poller's versions
    VoteBlock.Version[] vbVersions = pBlock.getVersions();
    for (int versionIndex = 0; versionIndex < vbVersions.length;
	 versionIndex++) {
      VoteBlock.Version vbVersion = vbVersions[versionIndex];
      if (vbVersion.getHashError()) {
	log.warning("Poller version "+versionIndex+" had a hashing error.");
      } else {
	HashResult pollerPlainHash;
	try {
	  pollerPlainHash = HashResult.make(vbVersion.getPlainHash());
	} catch (HashResult.IllegalByteArray e) {
	  log.warning("Poller version "+versionIndex+
		      " had an IllegalByteArray plain hash.");
	  continue;
	}
	VoteBlock.Version voterVersion = plainMap.get(pollerPlainHash);
	if (voterVersion != null) {
	  HashResult voterNoncedHash = HashResult.make(voterVersion.getHash());
	  try {
	    if (voterNoncedHash.equalsBytes(vbVersion.getHash())) {
	      return true;
	    }
	  } catch (HashResult.IllegalByteArray e) {
	    log.warning("Poller version "+versionIndex+
			" had an IllegalByteArray nonced hash.");
	    continue;
	  }
	  // The voter and poller match plain hash, but not nonced
	  // hash.
	  log.warning("Voter and poller matched plain but not nonced hash.");
	} 
      }
    }
    // No agreement on any version
    log.debug3("Disagree");
    return false;
  }

  /**
   * @return the percent for which the poller agrees with the us, the
   * voter.
   */
  public float percentAgreement() {
    // NOTE: Ignore the URLs the poller had but we didn't. The
    // agreement is based only on the subset we have.
    int total = countAgreeUrl() + countDisagreeUrl() + countVoterOnlyUrl();
    return total == 0 ? 0.0f : ((float)countAgreeUrl())/total;
  }

  /**
   * @return count of URLs that agree
   */
  protected int countAgreeUrl() {
    return agreeCount;
  }

  /**
   * @return List of URLs that agree
   */
  protected List<String> getAgreeUrls() {
    return agreeUrl;
  }

  /**
   * @return count of URLs that disagree
   */
  protected int countDisagreeUrl() {
    return disagreeCount;
  }

  /**
   * @return List of URLs that disagree
   */
  protected List<String> getDisagreeUrls() {
    return disagreeUrl;
  }

  /**
   * @return count of URLs that exist only at voter
   */
  protected int countVoterOnlyUrl() {
    return voterOnlyCount;
  }

  /**
   * @return List of URLs that exist only at voter
   */
  protected List<String> getVoterOnlyUrls() {
    return voterOnlyUrl;
  }

  /**
   * @return count of URLs that exist only at poller
   */
  protected int countPollerOnlyUrl() {
    return pollerOnlyCount;
  }

  /**
   * @return List of URLs that exist only at poller
   */
  protected List<String> getPollerOnlyUrls() {
    return pollerOnlyUrl;
  }

}
