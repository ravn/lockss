/*
 * $Id: VoteBlocksTallier.java,v 1.1.2.2 2013-01-20 18:17:46 dshr Exp $
 */

/*

Copyright (c) 2012 Board of Trustees of Leland Stanford Jr. University,
all rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
STANFORD UNIVERSITY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Stanford University shall not
be used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from Stanford University.

*/

package org.lockss.poller.v3;

import java.util.*;
import java.io.*;
import java.nio.*;

import org.lockss.hasher.HashBlock;
import org.lockss.protocol.VoteBlock;
import org.lockss.protocol.VoteBlocks;
import org.lockss.protocol.VoteBlocksIterator;
import org.lockss.util.*;


/**
 * Representation of the tally of two votes in a symmetric poll,
 * that is the one generated by the voter while it is creating its
 * vote, and the one generated at the poller while it is tallying
 * that vote. This class encapsulates the process of comparing
 * two VoteBlocks instances by comparing their lists of VoteBlock
 * instances and the hashes of the versions they contain.
 */
public class VoteBlocksTallier {
  private static final Logger log = Logger.getLogger("VoteBlocksTallier");
  private HashSet<String> agreeUrl = new HashSet<String>();
  private HashSet<String> disagreeUrl = new HashSet<String>();
  private HashSet<String> voterOnlyUrl = new HashSet<String>();
  private HashSet<String> pollerOnlyUrl = new HashSet<String>();
  /**
   * Used by the voter in a symmetric poll to tally the VoteBlocks
   * in the receipt message aginst the VoteBlocks object, which
   * was created during voter generation.
   * @param poller A ParticipantUserData instance to represent the poller
   * @param voterBlocks The VoteBlocks the voter generated
   * @param pollerBlocks The VoteBlocks the poller sent in the receipt.
   */
  public void tallyVoteBlocks(VoteBlocks voterBlocks,
				    VoteBlocks pollerBlocks) {
    Comparator<VoteBlock> comparator = new Comparator<VoteBlock>() {
      public int compare(VoteBlock vb, VoteBlock pb) {
        // null sorts after everything else.
        String vUrl = vb.getUrl();
        String pUrl = pb.getUrl();
        return StringUtil.compareToNullHigh(vUrl, pUrl);
      }
    };
    // VoteBlocks.iterator() delivers VoteBlock instances in URL order.
    try {
      VoteBlocksIterator vIterator = voterBlocks.iterator();
      VoteBlocksIterator pIterator = pollerBlocks.iterator();
      VoteBlock vBlock = null;
      VoteBlock pBlock = null;
    
      while (true) {
	if (vBlock == null) {
	  vBlock = vIterator.next();
	}
	if (pBlock == null) {
	  pBlock = pIterator.next();
	}
	if (vBlock == null && pBlock == null) {
	  // Run out of blocks in both iterators
	  break;
	}
	String vUrl = vBlock.getUrl();
	int comparison = comparator.compare(vBlock, pBlock);
	if (comparison == 0) {
	  // Voter and Poller both have this URL
	  if (voteBlockAgree(vBlock, pBlock)) {
	    agreeUrl.add(vUrl);
	  } else {
	    disagreeUrl.add(vUrl);
	  }
	  // Consume both VoteBlocks
	  vBlock = pBlock = null;
	} else if (comparison < 0) {
	  // Voter has this URL, Poller doesn't
	  voterOnlyUrl.add(vUrl);
	  // Consume the Voter's VoteBlock
	  vBlock = null;
	} else {
	  // Poller has this URL, Voter doesn't
	  pollerOnlyUrl.add(vUrl);;
	  // Consume the Poller's VoteBlock
	  pBlock = null;
	}
      }
    } catch (IOException ex) {
      log.error("IOException while tallying symmetric poll", ex);
      return;
    }
  }

  /**
   * Compare two VoteBlock instances, one from voter and one from poller.
   * @param vBlock VoteBlock from voter
   * @param pBlock VoteBlock from poller
   * @return true if at least one voter version agrees with a poller version
   */
  protected boolean voteBlockAgree(VoteBlock vBlock, VoteBlock pBlock) {
    // Build a HashSet of the poller's hashes
    HashSet<byte[]> pHashes = new HashSet<byte[]>();
    for (java.util.Iterator it = pBlock.versionIterator(); it.hasNext(); ) {
      VoteBlock.Version ver = (VoteBlock.Version)it.next();
      pHashes.add(ver.getHash());
    }
    // Look up each of the voter's hashes in the HashSet
    for (java.util.Iterator it = vBlock.versionIterator(); it.hasNext(); ) {
      VoteBlock.Version ver = (VoteBlock.Version)it.next();
      if (pHashes.contains(ver.getHash())) {
	// At least one voter version agrees with a poller version
	return true;
      }
    }
    // No agreement on any version
    return false;
  }

  /**
   * @return count of URLs that agree
   */
  protected int countAgreeUrl() {
    return agreeUrl.size();
  }

  /**
   * @return count of URLs that disagree
   */
  protected int countDisagreeUrl() {
    return disagreeUrl.size();
  }

  /**
   * @return count of URLs that exist only at voter
   */
  protected int countVoterOnlyUrl() {
    return voterOnlyUrl.size();
  }

  /**
   * @return count of URLs that exist only at poller
   */
  protected int countPollerOnlyUrl() {
    return pollerOnlyUrl.size();
  }
}
