/*
 * $Id: VoteBlocksTallier.java,v 1.2 2013-02-24 05:12:41 dshr Exp $
 */

/*

Copyright (c) 2012 Board of Trustees of Leland Stanford Jr. University,
all rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
STANFORD UNIVERSITY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Stanford University shall not
be used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from Stanford University.

*/

package org.lockss.poller.v3;

import java.util.*;
import java.io.*;
import java.nio.*;

import org.lockss.hasher.HashBlock;
import org.lockss.protocol.VoteBlock;
import org.lockss.protocol.VoteBlocks;
import org.lockss.protocol.VoteBlocksIterator;
import org.lockss.config.Configuration;
import org.lockss.config.CurrentConfig;
import org.lockss.util.*;


/**
 * Representation of the tally of two votes in a symmetric poll,
 * that is the one generated by the voter while it is creating its
 * vote, and the one generated at the poller while it is tallying
 * that vote. This class encapsulates the process of comparing
 * two VoteBlocks instances by comparing their lists of VoteBlock
 * instances and the hashes of the versions they contain.
 */
public class VoteBlocksTallier {
  private static final Logger log = Logger.getLogger("VoteBlocksTallier");
  // XXX DSHR cannot keep these lists of URLs in memory - need to put them
  // XXX DSHR on disk, and make collecting them optional since we actually
  // XXX DSHR only need the counts
  private boolean keepUrlLists = false;
  private ArrayList<String> agreeUrl = new ArrayList<String>();
  private int agreeCount = 0;
  private ArrayList<String> disagreeUrl = new ArrayList<String>();
  private int disagreeCount = 0;
  private ArrayList<String> voterOnlyUrl = new ArrayList<String>();
  private int voterOnlyCount = 0;
  private ArrayList<String> pollerOnlyUrl = new ArrayList<String>();
  private int pollerOnlyCount = 0;

  private static final String PREFIX = Configuration.PREFIX + "poll.v3.";

  /**
   * If true, lists of agree/disagree/voterOnly/pollerOnly URLs will
   * be kept. XXX see comment above
   */
  public static final String PARAM_KEEP_URL_LISTS =
    PREFIX + "keepurlLists";
  public static final boolean
    DEFAULT_KEEP_URL_LISTS = false;

  public VoteBlocksTallier() {
  }

  public VoteBlocksTallier(VoteBlocks voterBlocks, VoteBlocks pollerBlocks) {
    keepUrlLists = CurrentConfig.getBooleanParam(PARAM_KEEP_URL_LISTS,
						 DEFAULT_KEEP_URL_LISTS);

    tallyVoteBlocks(voterBlocks, pollerBlocks);
  }

  /**
   * Used by the voter in a symmetric poll to tally the VoteBlocks
   * in the receipt message aginst the VoteBlocks object, which
   * was created during voter generation.
   * @param poller A ParticipantUserData instance to represent the poller
   * @param voterBlocks The VoteBlocks the voter generated
   * @param pollerBlocks The VoteBlocks the poller sent in the receipt.
   */
  public void tallyVoteBlocks(VoteBlocks voterBlocks,
				    VoteBlocks pollerBlocks) {
    // VoteBlocks.iterator() delivers VoteBlock instances in URL order.
    try {
      VoteBlocksIterator vIterator = voterBlocks.iterator();
      VoteBlocksIterator pIterator = pollerBlocks.iterator();
      VoteBlock vBlock = null;
      VoteBlock oldVoterBlock = null;
      VoteBlock pBlock = null;
      VoteBlock oldPollerBlock = null;
    
      while (true) {
	if (vBlock == null && vIterator.hasNext()) {
	  vBlock = vIterator.next();
	}
	if (vBlock != null && oldVoterBlock != null) {
	  if (vBlock.compareTo(oldVoterBlock) < 0) {
	    log.error("Voter VoteBlocks out of order");
	    break;
	  }
	  oldVoterBlock = vBlock;
	}
	if (pBlock == null && pIterator.hasNext()) {
	  pBlock = pIterator.next();
	}
	if (pBlock != null && oldPollerBlock != null) {
	  if (pBlock.compareTo(oldPollerBlock) < 0) {
	    log.error("Poller VoteBlocks out of order");
	    break;
	  }
	  oldPollerBlock = pBlock;
	}
	if (vBlock == null && pBlock == null) {
	  // Run out of blocks in both iterators
	  break;
	} else if (vBlock == null) {
	  // Poller has blocks after Voter
	  if (keepUrlLists) {
	    pollerOnlyUrl.add(pBlock.getUrl());
	  }
	  pollerOnlyCount++;
	  // Consume the Poller's VoteBlock
	  pBlock = null;
	} else if (pBlock == null) {
	  // Voter has blocks after Poller
	  if (keepUrlLists) {
	    voterOnlyUrl.add(vBlock.getUrl());
	  }
	  voterOnlyCount++;
	  // Consume the Voter's VoteBlock
	  vBlock = null;
	} else {
	  String vUrl = vBlock.getUrl();
	  String pUrl = pBlock.getUrl();
	  int comparison = vBlock.compareTo(pBlock);
	  if (comparison == 0) {
	    log.debug3("Both have " + vUrl);
	    // Voter and Poller both have this URL
	    if (voteBlockAgree(vBlock, pBlock)) {
	      if (keepUrlLists) {
		agreeUrl.add(vUrl);
	      }
	      agreeCount++;
	    } else {
	      if (keepUrlLists) {
		disagreeUrl.add(vUrl);
	      }
	      disagreeCount++;
	    }
	    // Consume both VoteBlocks
	    vBlock = pBlock = null;
	  } else if (comparison < 0) {
	    log.debug3("Voter has " + vUrl);
	    // Voter has this URL, Poller doesn't
	    if (keepUrlLists) {
	      voterOnlyUrl.add(vUrl);
	    }
	    voterOnlyCount++;
	    // Consume the Voter's VoteBlock
	    vBlock = null;
	  } else {
	    log.debug3("Poller has " + vUrl);
	    // Poller has this URL, Voter doesn't
	    if (keepUrlLists) {
	      pollerOnlyUrl.add(pUrl);
	    }
	    pollerOnlyCount++;
	    // Consume the Poller's VoteBlock
	    pBlock = null;
	  }
	}
      }
    } catch (IOException ex) {
      log.error("IOException while tallying symmetric poll", ex);
      return;
    }
  }

  /**
   * Compare two VoteBlock instances, one from voter and one from poller.
   * @param vBlock VoteBlock from voter
   * @param pBlock VoteBlock from poller
   * @return true if at least one voter version agrees with a poller version
   */
  protected boolean voteBlockAgree(VoteBlock vBlock, VoteBlock pBlock) {
    // Build a HashSet of the poller's hashes. Works if elements are String
    // not if elements byte[]
    // XXX DSHR should be the same code as in the poller
    HashSet<String> pHashes = new HashSet<String>();
    for (java.util.Iterator it = pBlock.versionIterator(); it.hasNext(); ) {
      VoteBlock.Version ver = (VoteBlock.Version)it.next();
      String pHash = ByteArray.toHexString(ver.getHash());
      log.debug3("Poller hash " + pHash);
      pHashes.add(pHash);
    }
    // Look up each of the voter's hashes in the HashSet
    for (java.util.Iterator it = vBlock.versionIterator(); it.hasNext(); ) {
      VoteBlock.Version ver = (VoteBlock.Version)it.next();
      String vHash = ByteArray.toHexString(ver.getHash());
      log.debug3("Voter hash " + vHash);
      if (pHashes.contains(vHash)) {
	// At least one voter version agrees with a poller version
	log.debug3("Agree");
	return true;
      } else {
	log.debug3("No match with " + vHash);
      }
    }
    // No agreement on any version
    log.debug3("Disagree");
    return false;
  }

  /**
   * @return count of URLs that agree
   */
  protected int countAgreeUrl() {
    return agreeCount;
  }

  /**
   * @return List of URLs that agree
   */
  protected List<String> getAgreeUrls() {
    return agreeUrl;
  }

  /**
   * @return count of URLs that disagree
   */
  protected int countDisagreeUrl() {
    return disagreeCount;
  }

  /**
   * @return List of URLs that disagree
   */
  protected List<String> getDisagreeUrls() {
    return disagreeUrl;
  }

  /**
   * @return count of URLs that exist only at voter
   */
  protected int countVoterOnlyUrl() {
    return voterOnlyCount;
  }

  /**
   * @return List of URLs that exist only at voter
   */
  protected List<String> getVoterOnlyUrls() {
    return voterOnlyUrl;
  }

  /**
   * @return count of URLs that exist only at poller
   */
  protected int countPollerOnlyUrl() {
    return pollerOnlyCount;
  }

  /**
   * @return List of URLs that exist only at poller
   */
  protected List<String> getPollerOnlyUrls() {
    return pollerOnlyUrl;
  }

}
